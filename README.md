# Gk_Solver

Number theory research program by Ken Clements (Feb 2026).

## Overview

`Gk_Solver.py` finds the **minimum gap** k such that a **π-complete product** m·(m+k) exists for each prime set P_ω = {p₁,...,pω}.

```
m·(m+k)  is π-complete for P_ω  ⟺  prime support of m·(m+k) = P_ω exactly
```

Building the **min_gap(ω) table** across ω=9..20+ provides strong computational evidence that no π-complete products of any gap exist for large ω — a key step toward proving that n=633,555 gives the **last π-complete product n(n+1)** for gap=1.

This program is a companion to [Nr_Solver](https://github.com/kenatiod/Nr_Solver), which established that ω=8 (n=633,555) is the last π-complete consecutive pair (gap=1).

## Mathematical Framework

### Generalized Pell equation

For gap k, substitute x = 2m+k. Since (x−k)(x+k) = x²−k² = 4m(m+k) = 2qy²:

```
x² − 2q·y² = k²       (generalized Pell equation)
m = (x − k) / 2
```

For k=1 this recovers x²−2qy²=1, the equation used by Nr_Solver. ✓

### Multiple solution families

Unlike gap=1 (one family per mask), x²−2qy²=k² can have **multiple fundamental solution families**. Each family is generated by a different "reduced" solution (x₀,y₀) via the Pell automorphism:

```
x' = x₁·x + 2q·y₁·y
y' = y₁·x + x₁·y
```

where (x₁,y₁) solves x²−2qy²=1.

### Finding fundamental solutions: CRT stride search

For k=1: the only family is the standard Pell solution (pellxy). For k>1: any solution must satisfy x ≡ ±k (mod p) for each prime p|D. Using CRT this gives at most 2^ω residue classes mod D. We step through each class in **strides of D** — when D is large and max_x is bounded, each class has ≤1 candidate. This gives O(2^ω) complexity per mask instead of the O(k·√ε₁) of a naive linear search.

### Completeness guarantee (q-bound)

From x²−2qy²=k² with y≥1, x ≥ √(k²+2q), so m=(x−k)/2 ≥ (√(k²+2q)−k)/2. Setting m > max_m gives:

```
q > 2·max_m·(max_m+k)  →  skip this mask (no solution ≤ max_m)
```

For k=1 this reduces exactly to the Nr_Solver bound. ✓

### L-bound (primitive divisors)

Each family grows via the Pell automorphism at the same rate as Nr_Solver. The primitive divisor theorem (Bilu-Hanrot-Voutier 2001) guarantees that any P-smooth iterate occurs at position n ≤ pmax. So **L = max(3, pmax) iterates per family** suffices.

## Operating Modes

### Mode A: fixed_k

Enumerate all π-complete (m, m+k) pairs for a specific k value across ω range:

```bash
python3 Gk_Solver.py --mode fixed_k --gap_k 1 \
  --start_omega 8 --end_omega 9 --workers 4
# Reproduces Nr_Solver v17: finds m=633555 at omega=8, 0 hits at omega=9.

python3 Gk_Solver.py --mode fixed_k --gap_k 3 \
  --start_omega 9 --end_omega 17 --max_m 10000000 --workers 10
```

### Mode B: sweep_k

For each ω, find min_gap(ω) = smallest k with a π-complete hit:

```bash
python3 Gk_Solver.py --mode sweep_k \
  --start_omega 9 --end_omega 17 \
  --max_k 200 --max_m 10000000 --workers 10
```

Produces `min_gap_table.csv` and `min_gap_table.json` after each ω completes.

## Key Quantities

| Symbol | Meaning |
|--------|---------|
| **ω** | Number of distinct prime divisors (size of prime set P_ω) |
| **k** | Gap between the two factors: m and m+k |
| **min_gap(ω)** | Smallest k with a π-complete m·(m+k) for P_ω |
| **miss_star** | Minimum missing primes from P_ω across all candidates |
| **complete_enumeration** | True iff all masks processed and no failures |

## Installation

Requires Python 3.9+ and PARI/GP.

```bash
# macOS
brew install pari

# Linux
sudo apt install pari-gp
```

## Usage

```bash
python3 Gk_Solver.py [options]
```

**Key options:**

| Option | Default | Description |
|--------|---------|-------------|
| `--mode` | `fixed_k` | `fixed_k` or `sweep_k` |
| `--gap_k` | 1 | Gap size for fixed_k mode |
| `--max_k` | 200 | Maximum k in sweep_k mode |
| `--start_omega` | 8 | First ω to process |
| `--end_omega` | 20 | Last ω to process |
| `--workers` | cpu_count | Parallel worker processes |
| `--outdir` | auto | Output directory |
| `--max_m` | 0 (disabled) | Upper bound on m; required for k>1 |
| `--gp_path` | `gp` | Path to PARI/GP binary |
| `--full_report_omega_max` | 20 | Write full S-file + verify CSV only for ω ≤ this |

**Example — sweep min_gap for ω=9..17:**

```bash
python3 Gk_Solver.py --mode sweep_k \
  --start_omega 9 --end_omega 17 \
  --max_k 200 --max_m 10000000 \
  --workers 10 --gp_path /opt/homebrew/bin/gp
```

**Example — reproduce Nr_Solver result at gap=1:**

```bash
python3 Gk_Solver.py --mode fixed_k --gap_k 1 \
  --start_omega 8 --end_omega 8 --workers 4
# Should find pi_hits=1 at m=633555, complete=True
```

## Output

### fixed_k mode

For each (k, ω), writes to `{outdir}/k_{k:03d}/omega_{omega:02d}/`:

| File | Description |
|------|-------------|
| `S_p{pmax}_k{k}_omega_{omega:02d}.txt` | All candidate m values (both m and m+k P-smooth) |
| `verify_k{k}_omega_{omega:02d}.csv` | Per-m factorizations of m and m+k, π-complete flag |
| `summary_k{k}_omega_{omega:02d}.json` | Run metadata, SHA256 hashes, completeness flag |
| `run_k{k}_omega_{omega:02d}.log` | Progress log with timestamps |

### sweep_k mode

Same per-(k,ω) artifacts, plus at the top level:

| File | Description |
|------|-------------|
| `min_gap_table.csv` | min_gap(ω) row per omega |
| `min_gap_table.json` | Same as CSV in JSON format |

**min_gap_table columns:**

| Column | Meaning |
|--------|---------|
| `omega` | ω value |
| `pmax` | Largest prime in P_ω |
| `min_gap` | Smallest k with a π-complete hit, or `>max_k` |
| `certified` | True iff all k<min_gap had complete_enumeration=True |
| `pi_complete_m` | The m value of the first π-complete pair found |
| `pi_complete_m_plus_k` | m+k |
| `runtime_sec` | Total runtime for this ω (all k values) |

## Summary JSON Extensions (vs Nr_Solver)

Each `summary_k{k}_omega_{omega}.json` includes Nr_Solver's standard fields plus:

```json
{
  "k": 3,
  "gk_equation": "x^2 - 2*q*y^2 = k^2",
  "gk_q_bound": "q > 2*max_m*(max_m+k) = 2*10000000*(10000000+3)",
  "total_families_found": 12345,
  "masks_no_fundamental_sols": 67,
  "complete_enumeration": false
}
```

## Scientific Context

The primorial p_k# = product of first k primes. Nr_Solver established that n=633,555 is the last n with n(n+1) having prime support exactly P₈ (gap=1).

The scientific question Gk_Solver addresses: **does the minimum gap k for π-complete products grow without bound as ω increases?**

```
633,555 = 3³ × 5 × 13 × 19²
633,556 = 2² × 7 × 11³ × 17
```

Prime support = {2,3,5,7,11,13,17,19} = P₈, omega=8, gap=1, π-complete.

If min_gap(ω) → ∞ as ω → ∞, this is strong computational evidence (and with Baker bounds, a proof component) that no π-complete products of any gap exist for large ω.

## Relationship to Nr_Solver

| | Nr_Solver | Gk_Solver |
|-|-----------|-----------|
| Equation | x²−2qy²=1 | x²−2qy²=k² |
| Gap | 1 (consecutive) | k (variable) |
| Families/mask | 1 | O(2^ω) residue classes |
| Key output | Complete list of smooth pairs | min_gap(ω) table |
| Completeness | Størmer-Lehmer theorem | Baker bounds (work in progress) |

For k=1, Gk_Solver recovers Nr_Solver's results exactly (verified: finds m=633,555 at ω=8).

## Versioning

Git tags mark each released version. This repository begins at **v1**, the first version with:
- Generalized Pell x²−2qy²=k² for gap k>1
- CRT stride search for fundamental solutions (O(2^ω) per mask)
- sweep_k mode with min_gap_table output
- miss_star tracking in full verifier
- Full audit trail (SHA256, environment block, completeness flags)

## License

MIT License — see [LICENSE](LICENSE).
